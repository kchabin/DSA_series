# Detect a Cycle in an Undirected Graph

## BFS
### Cycle
그래프가 한 노드에서 시작해서, 같은 노드에서 끝나는 게 사이클.
BFS, DFS로 구현할 수 있다.

### BFS
Breadth First Search는 노드를 level-wise로 방문하는 traversal 기법이다. 동시에 같은 level의 노드들을 방문한 뒤, 다음 level로 이동한다.
- 한 노드에서 시작, BFS를 레벨 별로 수행한다.
- 탐색 도중 어느 시점에서든 하나의 노드를 두 번 방문 -> 두 개의 다른 경로를 통해 동일한 노드에 도달했다는 것을 의미한다.
- 이는 그래프에 사이클이 존재한다는 의미이다.
- 그래프가 연결되어 있거나 사이클을 포함하고 있는 경우에만 동일한 노드에 다시 도달할 수 있다.

## Approach
### Initial configuration
- Queue: <출발 노드, 부모 노드> 형태로 큐에 노드 쌍을 추가한다.
  - 예) (2, 1) 은 2번 노드가 현재 노드, 부모 노드가 1번 노드라는 것을 의미한다.
- Visited array: 방문 여부를 확인하는 배열. 0으로 초기화되어있고, 방문한 노드는 1로 표시한다.

### Algorithm steps
- BFS는 큐 자료구조와 visited 배열이 필요하다.
- <source, parent> 노드 쌍을 큐에 추가하고, 해당 노드를 방문한 노드로 마킹한다. 부모 노드는 역방향 탐색 없이 순방향으로만 탐색하기 위해서 필요하다.
- BFS 순회를 시작하고, 큐에서 요소를 매번 출력, 인접 리스트를 사용해 해당 노드의 아직 방문하지 않은 이웃 노드로 이동한다.
- 큐가 비게 되거나, 탐색 중 서로 다른 방향으로 이동했음에도 부모 노드가 아닌데 이미 방문 처리된 노드가 나타날 때까지 이 단계를 반복한다.
  - 이는 그래프에 사이클이 존재한다는 것을 나타낸다.
<img width="817" alt="스크린샷 2025-04-07 오전 12 45 00" src="https://github.com/user-attachments/assets/5ca9993b-3ada-4d97-a704-258d4d6af742" />

위 그림에서 5번 노드를 큐에서 뽑아내서 인접 리스트를 확인하면 부모 노드인 2는 이미 방문 처리되어서 무시하고, 아직 인접하지 않은 노드인 7번 노드로 이동하게 된다. 
이후 비슷한 단계를 반복하다가 6번 노드를 큐에서 출력해서 인접 리스트를 확인하고 이동하려하면 3은 부모 노드라 이미 방문한 노드이기 때문에 갈 수 없다.
다른 인접 노드인 7번 노드는 **부모 노드가 아니지만, 이미 방문 처리된 노드**이므로 위에서 말한 종료 조건에 부합한다. 따라서 현재 예시 그래프에는 사이클이 존재한다.

- 만약 큐가 비게 되고, 특정 조건을 만족하는 노드를 찾지 못했다면 그래프에 사이클이 없다는 의미 -> `false` 리턴
```
#check for connected components in a graph
for i in range(n):
  if not vis[i]:
    if detectCycle(i):
      return true
return false
```
